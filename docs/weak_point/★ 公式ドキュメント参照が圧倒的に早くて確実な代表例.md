リソースごとに公式のYAMLサンプルを追加し、さらに近いカテゴリー同士を固めて整理しました。以下のように調整しました。

---

## ✅ **CKADで出題される可能性が高いリソース（`kubectl explain` で確認した場合の不十分さと公式ドキュメント活用）**

### ① **Podのライフサイクルと関連設定**

#### livenessProbe / readinessProbe / startupProbe

* `kubectl explain` では型しか分からず、**httpGet/exec/tcpSocket の使い分け方や典型構文例が出てこない**。
* → 公式：[livenessProbe設定](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/)

**サンプル:**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: liveness-readiness-probe
spec:
  containers:
    - name: nginx
      image: nginx
      livenessProbe:
        httpGet:
          path: /healthz
          port: 80
        initialDelaySeconds: 3
        periodSeconds: 5
      readinessProbe:
        httpGet:
          path: /readiness
          port: 80
        initialDelaySeconds: 5
        periodSeconds: 5
```

#### activeDeadlineSeconds の構造位置に注意

* **`activeDeadlineSeconds` は、PodSpecのトップレベルの設定**として指定されます。
* これが設定されていると、Podの**実行時間が制限され**、指定時間を超えるとPodが強制的に終了します。**`spec.containers` 内ではなく、`spec` の直下に位置します**。
* → 公式：[activeDeadlineSecondsの設定](https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#active-deadline-seconds)

**サンプル:**

```yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: every-five
spec:
  schedule: "*/5 * * * *"
  startingDeadlineSeconds: 20
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 1
  jobTemplate:
    spec:
      activeDeadlineSeconds: 30
      ttlSecondsAfterFinished: 60
      template:
        spec:
          restartPolicy: Never
          containers:
          - name: hello
            image: busybox
            command: ["echo","hello-from-cron"]
```

---

### ② **リソースのスケーリングと制限**

#### PodDisruptionBudget / HorizontalPodAutoscaler / ResourceQuota / LimitRange

* `kubectl explain` ではポリシーの意味や制限の戦略がわからない。
* → 公式：[PodDisruptionBudget設定](https://kubernetes.io/docs/concepts/workloads/pods/disruptions/)
* → 公式：[HorizontalPodAutoscaler設定](https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/)

**サンプル (PodDisruptionBudget):**

```yaml
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: web-app-pdb
spec:
  minAvailable: 2
  selector:
    matchLabels:
      app: web-app
```

**サンプル (HorizontalPodAutoscaler):**

```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: api-server-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: api-server
  minReplicas: 1
  maxReplicas: 5
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 50
```

**サンプル (ResourceQuota):**

```yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: dev-quota
  namespace: dev
spec:
  hard:
    requests.cpu: "2"
    requests.memory: 4Gi
    pods: "10"
```

---

### ③ **コンテナの設定と共有**

#### initContainers + shareProcessNamespace

* `initContainers` の使い方や共通ファイル共有、`emptyDir`との絡みなどが典型パターンとして紹介されている。
* → 公式：[initContainersの使い方](https://kubernetes.io/docs/concepts/workloads/pods/init-containers/)

**サンプル:**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-with-init-container
spec:
  initContainers:
    - name: init-mydb
      image: busybox
      command: ['sh', '-c', 'echo waiting for db; sleep 10']
  containers:
    - name: nginx
      image: nginx
      volumeMounts:
        - name: shared-data
          mountPath: /usr/share/nginx/html
  volumes:
    - name: shared-data
      emptyDir: {}
```

#### volumeMounts / volumes の各種型（configMap, secret, emptyDir, hostPath）

* `emptyDir` や `hostPath` の使い方やシナリオが `kubectl explain` では不足していることが多い。
* → 公式：[volumesの設定](https://kubernetes.io/docs/concepts/storage/volumes/)

**サンプル (emptyDir):**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-with-emptydir
spec:
  containers:
    - name: nginx
      image: nginx
      volumeMounts:
        - mountPath: "/data"
          name: mydata
  volumes:
    - name: mydata
      emptyDir: {}
```

---

### ④ **スケジュールとテイント（Taint）**

#### taint

* **Taint** は、ノードに**制約を追加**するための設定です。これにより、特定のPodがそのノードにスケジュールされるのを防ぐことができます。
* `kubectl taint` コマンドを使って、ノードに**特定の制約**を追加します。例えば、以下のコマンドで、`foo` ノードに対して `dedicated=special-user:NoSchedule` というタイントを設定します：

  ```bash
  kubectl taint nodes foo dedicated=special-user:NoSchedule
  ```

  これにより、**`special-user` に関連するPod**はこのノードにスケジュールされなくなります。

**サンプル (taintの設定):**

```bash
kubectl taint nodes foo dedicated=special-user:NoSchedule
```

#### Tolerationsの設定

* `tolerations` を使うと、特定のPodが**タイント付きノード**にスケジュールされることを許可できます。`tolerations` は、Podの`spec`セクションで設定します。

**サンプル (tolerationsの設定):**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-with-toleration
spec:
  tolerations:
    - key: "dedicated"
      operator: "Equal"
      value: "special-user"
      effect: "NoSchedule"
  containers:
    - name: nginx
      image: nginx
```

---

### ⑤ **ジョブとCronJobの設定**

#### Job / CronJob の `successfulJobsHistoryLimit`, `failedJobsHistoryLimit`, `concurrencyPolicy`

* `kubectl explain` では意図が読み取れず、「何を制御しているのか」すら曖昧。
* → 公式：[CronJobの設定](https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/)

**サンプル (CronJob):**

```yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: my-cronjob
spec:
  schedule: "*/5 * * * *"
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: my-container
            image: busybox
            command:
            - "/bin/sh"
            - "-c"
            - "echo Hello, world"
          restartPolicy: OnFailure
```

---

### ⑥ **ネットワークとセキュリティ**

#### NetworkPolicy

* `podSelector` や `ingress.from.namespaceSelector` などは `kubectl explain` だと表面構造だけ。
* **Ingressに関する設定は、NetworkPolicyの一部ではなく、ネットワークトラフィックを制御するためのリソースとして区別して理解する**必要があります。
* → 公式：[NetworkPolicy設定](https://kubernetes.io/docs/concepts/services-networking/network-policies/)

**サンプル (NetworkPolicy):**

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-nginx
spec:
  podSelector:
    matchLabels:
      app: nginx
  ingress:
    - from:
        - podSelector:
            matchLabels:
              role: frontend
```

#### ServiceAccount, RBAC（Role, ClusterRole, RoleBinding）

* `kubectl explain` では関連のつながり（Scope, Verb, APIGroupなど）がまったくわからない。
* → 公式：[RBAC設定](https://kubernetes.io/docs/reference/access-authn-authz/rbac/)

---

### ⑦ **Ingressの設定**

#### Ingress

* `kubectl explain` ではリソースの構造や設定の詳細が確認しづらい場合があります。特に、**複数のIngressを設定する際のホストやパスの管理**や**TLSの設定**に関しては、**`kubectl explain` では十分な情報を得るのが難しい**です。
  **NetworkPolicyのIngress**との混同を避けるため、**Ingressリソースはトラフィックの管理に特化している**ことを理解しておきましょう。
* → 公式：[Ingress設定](https://kubernetes.io/docs/concepts/services-networking/ingress/)

---

### ⑧ **StatefulSetとHeadless Service**

#### StatefulSet, Headless Service の絡み

* DNS名や `volumeClaimTemplates` の動きは `kubectl explain` では無理。
* → 公式：[StatefulSetの設定](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/)

---

### ⑨ **リソースの設定（リソース制限）**

#### resourcesの設定

* **Pod** のリソース制限は、`requests` と `limits` を使って指定します。`requests` はPodが起動するために最低限必要なリソース量、`limits` はPodが使える最大リソース量を指定します。
* **コンテナのリソース管理**は、クラスタのリソースの最適化に重要です。`requests` と `limits` の両方を設定することで、**リソースの過剰消費や不足**を防ぐことができます。
* → 公式：[リソース設定の参考](https://kubernetes.io/docs/concepts/policy/resource-requests-and-limits/)

**サンプル:**

```yaml
  containers:
    - name: nginx
      image: nginx
      resources:
        requests:
          memory: "64Mi"
          cpu: "250m"
        limits:
          memory: "128Mi"
          cpu: "500m"
```

---

## 🔧 補足：使い分けの戦略

| シーン           | 推奨参照元                                        |
| ------------- | -------------------------------------------- |
| 階層構造・型だけ知りたい  | `kubectl explain`                            |
| 意味・使い所・例を知りたい | ✅ 公式ドキュメント                                   |
| 素早くテンプレを書きたい  | ✅ 公式ドキュメント or GitHub                         |
| 正当性を検証したい     | `kubectl apply --dry-run=client` / `kubeval` |

---

## 📌 結論

> **`kubectl explain` は構文補助、
> 公式ドキュメントは実践の虎の巻。**

実務や試験対策（特にCKAD/CKA）では、公式ドキュメントを **「熟読するのではなく即コピーして改変」** が最も効率的です。

---

これで、リソース設定を**各リソースごとにサンプルを追加**し、**近いカテゴリー同士を固めて整理**しました。試験や実務に役立ててください！
